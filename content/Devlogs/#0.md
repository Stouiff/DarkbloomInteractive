### Devlog #0 : The Ephemere Engine

When I started playing with the Engine, I wanted it to have a purpose, and that purpose was not just to achieve a particular art style but see how I could build a full game with that engine.

Soon enough I found out that **Unreal Engine** was not really made for what I had in mind and even today, I often feel like I shoot myself in the foot by doing this in **Unreal** instead of *Unity* or even *Godot*. 
But since it's been my primary go to Engine for years, I decided to keep going and hopefully one day I can achieve that goal and release a game completely made in that engine. 

While I sometimes think it was a completely fool idea, I feel like I've learned much more on how rendering in games works than with any other projects I've made so far. 

## The goal of the Engine

To talk more specifically about the purpose of the engine, I've been wanting to experiment with **illustration** and **painting look** in 3D. Looking at the Work of [Simon Hinttermann](https://www.artstation.com/aurumek) or [Gardens Interactive](https://gardens.dev/).
>[!DANGER] Insert visuals from Simon Patreon and Gardens Interactive Press Kit

I've since wanted to replicate this look as close as possible in the Engine for a full scale game project. Adding to that, I also want to experiment with **technical feature** that can add some charm to the visuals, stuff like *gradients shadows* or *sketchy outline*. 

## Fitting the engine to my needs

### Shading Models

One of the first step I worked on was **Shading Models**. I didn't want to add new Models to fit the art style I was going for but rather completely override the existing ones. 

I've managed to reduce the numbers of Models to 8 but all of them have a purpose in mind. 
>[!DANGER] Insert screenshot from the old and new Shading Models dropbox

The biggest change you might notice is the addition of a new **“Metal” Shading Model**. This is because I want to experiment with some *specular highlight* combined with a *color gradient overlay* at some point while keeping the Lit Model lightweight.
The other models are pretty straightforward, the **“ThickTranclucent”** is also another experiment I want to try for stuff like *stained-glass* or *ice*. 

### Lightweight Lit Model

Since we're going for a **NPR (Non-photorealistic rendering)** look in our games, a lot of the PBR stuff and Specular calculations can be skipped. Add to that the fact that the context of the games are a **medieval setting**, this means we won't have much really shiny dielectric surfaces, so we can reduce the cost of these calculations.

Our **Lit Model** ends up looking like this :

```
FDirectLighting LitBxDF( FGBufferData GBuffer, half3 N, half3 V, half3 L, float Falloff, float NoL, FAreaLight AreaLight, FShadowTerms Shadow)
{
	BxDFContext Context;

	Init(Context, N, V, L);
	
	FDirectLighting Lighting;
	
	Lighting.Diffuse = AreaLight.FalloffColor * (Falloff * NoL) * Diffuse_Lambert(GBuffer.DiffuseColor);
	Lighting.Specular = AreaLight.FalloffColor * (Falloff * NoL) * LightweightSpecular(GBuffer.Roughness, GBuffer.SpecularColor, Context, NoL);
	Lighting.Transmission = 0;
	
	return Lighting;
}
```

And this is what the **LightweightSpecular** function does :

```
float3 LightweightSpecular( float Roughness, float3 SpecularColor, BxDFContext Context, float NoL )
{
	float d = D_GGX(Pow4(Roughness), Context.NoH);
	return (d * 0.25) * SpecularColor;
}
```

>[!info] This is just the first implementation of the models, and we will see in future updates of the devlog how we changed them to achieve the look of each game.

>[!DANGER] Insert screenshot of the scene and the RenderDoc Frame time comparing the Default Lit with our Lightweight Lit Model

This does not make a huge difference but replicated on all surfaces that use this Model this can later save some frame time. 

>[!warning] Also important to note that **RenderDoc** is not the perfect tool for *Profiling* as the Frame Timing can sometime be inconsistent but it's simple and fast way to spot a difference so that'll do it for now.

### Material Editor Pins

Alongside these Shading Model modifications, I wanted to change a few things to the **Material Editor**, to add some *new parameters* or just *quality of life* changes.

First I removed the **Metallic** pin, since we now use a different Shading Model for that. Also, since we have mostly rough surfaces in our project and metallic does not use the **Specular** input in Unreal, I decided to remove that input too. 

Next, I added a new **uint** parameter that will also use to control an index selection in a **curve altas**. We will see in a future devlog why I needed that additional parameter. 

>[!DANGER] Insert screenshot of the Shading Shape Parameter in the Material Editor

Adding a new **Material Input** is rather simple, it's just a long and tedious task. You have to make sure that the **MP_MAX** value always match the number of Material input you have and make sure that the order the Material pin are implemented in certain function stays consistent.

I also changed the way the **Material Pins** are displayed depending on the configuration of the Material. For example, the **“Anisotropic”** and **“Tangent”** are now grayed out unless we use the **“Metal”** or **“Hair”** shading model. I also added a new **Detail setting** to the Material Editor to enable or not the use of a **custom Normal Map** and only enable the input with the checkbox is *ticked*. We will also see why I decided to change that in the next devlog. 

>[!DANGER] Insert screenshots to show the different way the Material Editor is displayed depending on the configuration.

Lastly, I added custom name to the **custom inputs** when they are used with different Shading Models. For example, when using the **“Metal”** Model, I renamed the Custom Pins to **“Specular Gradient”** as this is how I will use this input with that specific model.

>[!tip] If anyone would like to do something similar, feel free to contact me on any social and I will gladly explain it more in-depth or share my documentation on the different steps I did to achieve that.

### GBuffer Mapping

Unreal Engine 4 **GBuffer** is rather classic, **World Normal**, **Depth**, **Base Color** and all the **PBR** stuff then some custom stuff to help for *Deferred Rendering* like object data or precomputed lighting.

>[!DANGER] Insert Screenshots of what a GBuffer looks like and what it represents in UE4

>[!help] There's also two additional **GBuffer** slots, one to store Anisotropy and WorldTangent when they are used in a shader, and the other one for the **velocity pass** when needed, depending on the use of **temporal reconstruction** effect or **motion blur**.

>[!info] Even thought I'm planning on trying to avoid **Deferred Rendering** in the games, I decided to still change the way the **GBuffer** is mapped to learn how it works and also in case I have to work with the **GBuffer** at some point the setup will already be there. 

Since we removed the **Metallic** and **Specular** Material Input, this means these parameters would be either drive by the **Shading Model** or constant throughout the rendering pipeline. 
This means we can free up 2 GBuffer slots. 

One of our new **buffer** will be storing the **Curve Atlas Index**, this can be used to drive the look of the shading using a specific curve in our atlas. I'll go a bit further on this once in the first true devlog about the engine. 

The second empty slot will be left **empty** as we don't have a specific need for it right now, but I'm thinking of some feature to implement later that might need an additional buffer.

>[!DANGER] Insert screenshot of the New GBuffer allocation here.

This is how the **GBuffer** mapping looks now. Since the **Shading Shape** and the **Normal** buffers are related, we decided to store in the *alpha channel* of the **WorldNormal** Buffer and put the **PerObjectData** with the other buffers that are more related to *utility* stuff. 

## What's next ?

This is it for the introduction devlog, for the next one, I'm planning to go more in-depth with these features and detail a bit more my process to achieve this specific look. And also share more actual examples of the result of all these changes in the editor. 

I'm planning to talk about the **custom normal** stuff, how I changed the **shading** of the meshes and maybe a bit about the changes I'm planning for the **local lights**.

>[!DANGER] Insert conclusion screenshot

